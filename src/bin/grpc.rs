/*
 * grpc.rs
 *
 * This Rust program initializes and starts a gRPC server using the tonic framework.
 * It supports two modes of client communication: REST and binary, controlled by feature flags.
 *
 * Features:
 * - `rest`: Enables REST client communication.
 * - `binary`: Enables binary client communication.
 *
 * The program performs the following steps:
 * 1. Initializes logging based on environment settings.
 * 2. Loads application settings from a configuration file.
 * 3. Creates a client for communication based on the enabled feature flag (`rest` or `binary`).
 * 4. Configures and starts a gRPC server on the specified address and port.
 *
 * Note: Either the `rest` or `binary` feature must be enabled for the program to compile and run.
 * The default feature set in `Cargo.toml` is `rest`.
 *
 * Usage:
 * To run the server with REST client support:
 *   cargo run --bin grpc --features rest (NOTE: `--features rest` can be omitted as it's the default)
 *
 * To run the server with binary client support:
 *   cargo run --bin grpc --features binary
 */

#![allow(unused_imports)] // turned on to silence clippy warnings due to using feature flags
use std::env;

use cfg_if::cfg_if;
use env_logger::Builder;
use log::info;
use tonic::transport::Server;

use mighty_grpc::config::AppSettings;
#[cfg(feature = "binary")]
use mighty_grpc::services::clients::binary::BinaryClient;
use mighty_grpc::services::clients::MightyClient;
#[cfg(feature = "rest")]
use mighty_grpc::services::clients::rest::MightyServerRestClient;
use mighty_grpc::services::server_proxy::create_mighty_inference_server;

#[cfg(not(any(feature = "rest", feature = "binary")))]
compile_error!("You must enable either the `rest` or `binary` feature.");

fn init_logging() {
    let mut builder = Builder::from_default_env();
    builder.filter(Some("h2"), log::LevelFilter::Warn);
    builder.filter(Some("hyper"), log::LevelFilter::Warn);
    builder.init();
}

fn create_client(settings: &AppSettings) -> Box<dyn MightyClient> {
    cfg_if! {
        if #[cfg(feature = "rest")] {
            let mighty_server_config = settings
                .mighty_server
                .as_ref()
                .expect("Mighty Server configuration is missing");
            let base_url = mighty_server_config
                .base_url
                .as_ref()
                .expect("Base URL for Mighty Server is missing");
            Box::new(MightyServerRestClient::new(base_url.clone()))
        } else if #[cfg(feature = "binary")] {
            Box::new(BinaryClient::new())
        } else {
            unreachable!("No valid client configuration found")
        }

    }
}

static FILE_DESCRIPTOR_SET: &[u8] = include_bytes!("../proto/mighty_inference.bin");

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let settings = AppSettings::new()?;
    env::set_var("RUST_LOG", &settings.logging.level);
    init_logging();

    let client = create_client(&settings);

    let addr = format!(
        "{}:{}",
        settings.grpc_server.address, settings.grpc_server.port
    )
    .parse()?;
    info!("gRPC Server listening on {}", addr);

    // Set up the gRPC reflection service using the generated byte code
    let reflection_service = tonic_reflection::server::Builder::configure()
        .register_encoded_file_descriptor_set(FILE_DESCRIPTOR_SET)
        .build()?;

    Server::builder()
        .add_service(create_mighty_inference_server(client))
        .add_service(reflection_service)
        .serve(addr)
        .await?;

    Ok(())
}
